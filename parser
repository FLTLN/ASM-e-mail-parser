.286
code_seg segment
        ASSUME  CS:CODE_SEG,DS:code_seg,ES:code_seg
	org 100h
start:
    jmp begin
	
;########################################################################################################################
;#											Функции и макросы для подсчёта времени									   	#
;########################################################################################################################

;========================================================================================================================
;											Макрос, сохраняющий вектор прерывания
;========================================================================================================================

get_vector	macro	vector, DD_for_save_vector
		pusha
		push	ES
		
		mov AX,35&vector   
		int 21h 
	  
		mov word ptr DD_for_save_vector, BX 	
		mov word ptr DD_for_save_vector+2, ES  	
		
		pop	ES
		popa
endm

;========================================================================================================================
;											Макрос, устанавливающий вектор прерывания
;========================================================================================================================
	
set_vector macro vector, handler

		mov DX,offset handler      
                             
		mov AX,25&vector          
                              
		int 21h  							
endm

;========================================================================================================================
;									Макрос, восстанавливающий вектор прерывания из сохранённого
;========================================================================================================================

recovery_vector	macro vector,DD_for_save_vector
		pusha
		push	ES
		push	DS
		
		lds    DX, 	CS:DD_for_save_vector   
		mov 		AX,	25&vector        ; Заполнение вектора старым содержимым
		int    21h	
	
		pop		DS						;	DS:DX - указатель программы обработки прер.
		pop		ES
		popa
endm

;========================================================================================================================
;											Макрос, начинающий подсчёт времени
;========================================================================================================================

start_time macro saved_vector_1Ch, count
local	nxt, new_1Ch

		get_vector	1Ch,	saved_vector_1Ch
		set_vector	1Ch,	new_1Ch

		jmp nxt
		
new_1Ch	proc	far
		pushf
		inc		CS:count
		popf
		jmp		dword ptr CS:	[saved_vector_1Ch]
new_1Ch	endp	
nxt:
;
endm

;========================================================================================================================
;											Макрос, заканчивающий подсчёт времени
;========================================================================================================================

finish_time	macro	saved_vector, count
local	nxt, old_1Ch,new_1Ch

		recovery_vector	1Ch,	saved_vector
		Print_Word_hex	count

endm

;========================================================================================================================
;											Макрос, выводящий src в hex виде
;========================================================================================================================

Print_Word_hex macro src	
local	next, print_DL, print_hex, print_, msg

		CR	EQU	13
		LF	EQU	10
		
		push AX
		push BX
		push CX
		push DX
			
		mov	BX,	src
		mov AH,02
		mov DL,BH
		call print_DL
 
		mov DL,BL
		call print_DL
	
		pop	DX
		pop	CX
		pop	BX
		pop	AX

		jmp	next

;========================================================================================================================
;											Процедура, выводящая DL в hex виде
;========================================================================================================================

print_DL proc near
		push DX
		rcr	DL,4
		call print_hex
		pop	DX
		call print_hex
		ret
print_DL	 endp		

;========================================================================================================================
;									Процедура, преобразовывающая hex значение в ascii код
;========================================================================================================================

print_hex proc near
		and	DL,	0Fh
		add	DL,	30h
		cmp	DL,	3Ah
		jl		print_
		add	DL,	07h
print_:	
		int	21H
		ret
print_hex endp	

next:
endm

		old_1Ch	DD ?
		old_08h	DD ?
		time_count DW ?
		count_ DW ?

		count1 DW ?
		msg	DB 'Hello world!!!!!!!!!!!',13,10,'$'
		msg1 DB	' ',13,10,'$'

;########################################################################################################################
;#											Начало работы парсера												   		#
;########################################################################################################################

;========================================================================================================================
;											Получаем имя файла для парсинга
;========================================================================================================================

begin:										
		mov SI, 128							;с этим смещением в PSP лежит количество символов в консоли
		lodsb
	
		cmp AX, 0000h						;сравниваем с нулём
		jnz lp								;если не 0, продолжаем обработку

		call print_error					;инаце вызываем процедуру печати ошибки
		int 20h								;и возвращаем управление в ОС
lp:				
		lodsb								;загружаем символ из PSP
	
		cmp AL, 0Dh							;сравниваем с ASCII кодом Enter'а
		jnz lp								;повторяем в цикле, пока не найдём энтер
	
		dec SI								;уменьшаем SI, чтобы смещение указывало на позицию где лежит код Enter'a
		xor AL,AL							;обнуляем AL
		mov DS:[SI], byte ptr AL			;записываем на место Enter'a 0, получаем ASCIIZ строку
pass1:

;========================================================================================================================
;											Открываем файл для парсинга
;========================================================================================================================

		mov ah,3Dh           				;функция открытия файла
		xor al,al               			;режим для чтения
		mov dx,130    						;адрес первого символа ASCIIZ строки с именем файла         
		int 21h								;открываем файл 
	
		jnc pass2							;если открыли удачно, обрабатываем дальше
	
		call print_error					;иначе выводим сообщение об ошибке
		
		int 20h								;и возвращаем управление
pass2:
		mov handle, AX						;запоминаем хендлер
		
;========================================================================================================================
;											Создаём файл для результатов парсинга
;========================================================================================================================

		mov ah,3Ch           				;функция создания файла
		mov dx,offset f_adr2     			;адрес первого символа ASCIIZ строки с именем файла 
		xor cx,cx               			;атрибут файла	
		int 21h 							;создаём файл
	
		jnc pass3							;если создали удачно, обрабатываем дальше
	
		call print_error					;иначе выводим сообщение об ошибке
		
		int 20h								;и возвращаем управление
pass3:
		mov handle2, AX						;запоминаем хендлер
		
;========================================================================================================================
;											Подготовительный блок
;========================================================================================================================

		mov DI, offset o_buf				;адрес бфера для обработки строк
	
		mov valid_count, 0					;количество валидных емейлов
		mov unvalid_count, 0				;количество невалидных емейлов
		
		start_time	old_1Ch, time_count
		
;========================================================================================================================
;											Основаня логика программы
;========================================================================================================================
		
rep_load:
		call refresh_buf					;загружаем фрагмент файла в буфер
	
		cmp AX, 45000						;если загрузили меньше полного буфера
		jne last_data						;уходим на обработку буфера без повторной загрузки
	
		mov CX, AX							;количество символов в счётчик цикла
rep_no_last_data:
		
		lodsb								;загружаем символ из файла
		
		call symbol_proc					;вызываем процедуру обработки символа
		loop rep_no_last_data				;уходим на следующую итерацию цикла
	
		jmp rep_load						;после обработки всех символов вбуфере, прыгаем на загрузку нового фрагмента

last_data:									;сюда попадём если обрабатываем остаток файла									
		mov CX, AX							;количество символов в счётчик цикла
rep_last_data:
		lodsb								;загружаем символ из файла
	
		call symbol_proc					;вызываем процедуру обработки символа
	
		loop rep_last_data					;уходим на следующую итерацию цикла
		
;========================================================================================================================
;											Вывод статистики
;========================================================================================================================
		
		mov AH, 9							;новая строка
		mov DX, offset mes_eol
		int 21h
				
		mov DX, offset mes_time				;сообщение о выводе времени
		int 21h
				
		finish_time	old_1Ch, time_count		;вывод времени
				
		mov AH, 9							;новая строка
		mov DX, offset mes_eol
		int 21h
				
		mov DX, offset mes_valid			;сообщение о выводе количества валидных емейлов
		int 21h
	
		Print_Word_hex valid_count			;вывод количества валидных
				
		mov AH, 9							;новая строка
		mov DX, offset mes_eol
		int 21h
				
		mov DX, offset mes_unvalid			;сообщение о выводе количества невалидных емейлов
		int 21h
				
		Print_Word_hex unvalid_count		;вывод количества невалидных
				
		mov AH, 9
		mov DX, offset mes_eol				;новая строка
		int 21h
	
		mov AH, 3Eh							;процедура закрытия файла
		mov BX, offset handle				;указатель на входной файл
		int 21h								;закрываем файл
	
		mov AH, 3Eh							;процедура закрытия файла
		mov BX, offset handle2				;указатель на выходной файл
		int 21h								;закрываем файл
	
		int 20h								;возврат управления в ОС
	
	
;########################################################################################################################
;#											Конец работы парсера													   	#
;########################################################################################################################



;########################################################################################################################
;#											Процедуры парсера												   			#	
;########################################################################################################################

;========================================================================================================================
;											Процедура обновления буфера															
;========================================================================================================================
	
refresh_buf proc

		mov AL, '|'							;будем выводить этот символ при каждом обновлении буфера
		int 29h								;чтобы иметь возможность смотреть на них и радоваться
	
		mov BX, handle						;указатель на файл		
		mov AH, 3Fh							;процедура чтения
		mov DX, offset buf					;адрес входного буфера
		mov CX, 45000						;размер входного буфера 
		int 21h								;читаем
	
		mov SI, offset buf					;SI на начало буфера
		
		ret									;Возврат из прерывания
		
refresh_buf endp

;========================================================================================================================
;											Процедура обработки символа															
;========================================================================================================================
	
symbol_proc proc
	
		mov DS:[DI], byte ptr AL			;Записываем считанный символ в буфер для обработки строки
		inc DI								;Увеличиваем DI, чтобы смещение указывало на следующий символ
	
		cmp AL, '@'							;Сравниваем загруженный символ с @
		jne no_a							;Если не @, уходим на следующие сравнения
		mov DH, 1							;Еденица в DH будет флагом наличия @ в строке
		jmp symbol_done						;Завершаем обработку символа
no_a:
	
		cmp AL, 0Dh							;Сравниваем с Enter
		jne no_enter						;Если не он, обрабатываем дальше
	
		call line_proc						;Вызываем процедуру обработки строки
		jmp symbol_done						;Завершаем обработку символа
no_enter:
	
		cmp AL, ' '							;Сравниваем с пробелом
		jne no_bsp							;Если не он, обрабатываем дальше
	
		call line_proc						;Вызываем процедуру обработки строки
		jmp symbol_done						;Завершаем обработку символа
no_bsp:
	
		cmp AL, ';'							;Запятая и точка с запятой - аналогично
		jne no_tz
	
		call line_proc
		jmp symbol_done
no_tz:
	
		cmp AL, ','
		jne no_z
	
		call line_proc
		jmp symbol_done
no_z:
	
symbol_done:
	
		ret									;Возврат из прерывания
symbol_proc endp

;========================================================================================================================
;											Процедура обработки строки															
;========================================================================================================================
	
line_proc proc
	
		cmp DH, 1							;Проверяем, нашли ли емейл в строке
		jne no_email_pass					;Если не нашли, уходим на конец обработчика
	
		dec DI								;Уменьшаем DI, чтобы не обрабатывать символ конца строки
	
		push SI								;Сохраняем SI в стеке, так как будем использовать его для обработки строки
		
		mov SI, offset o_buf				;В SI адрес буфера со строкой для обработки 
		
;========================================================================================================================
;											Обработка перед знаком @ 															
;========================================================================================================================
		lodsb 								;Загружаем первый байт
	
		cmp AL, '.'							;Если точка - емейл не валидный
		je unvalid_pass
		
		cmp AL, '-'							;Дефис - аналогично
		je unvalid_pass
		
		cmp AL, '@'							;Первый символ @ - емейл невалидный
		je unvalid_pass

		jmp start_common_pre_a				;Прыгаем на начало обычной обработки
pre_a:		
		lodsb								;Загружаем следующий байт
		
		start_common_pre_a:
	
		cmp AL, 122							;Отсекаем этой проверкой всю киррилицу и спецсимволы
		jg unvalid_pass
	
		cmp AL, 96							;Эта проверка пропускает латиницу нижнего регистра
		jg end_pre_a
	
		cmp AL, '_'							;Пропускаем нижнее подчёркивание
		je end_pre_a						
	
		cmp AL, 90							;Отсекаем спецсимволы, расположенные между латиницей нижнего и верхнего регистра
		jg unvalid_pass						;По этой проверке должно отсекаться и нижнее подчёркивание, но мы пропустли его ранее
	
		cmp AL, 63							;Эта проверка пропускает латиницу нижнего регистра
		jg end_pre_a
	
		cmp AL, 57							;Отсекаем спецсимволы между цифрами и латиницей
		jg unvalid_pass
	
		cmp AL, 47							;Пропускаем цифры
		jg end_pre_a
	
		cmp AL, '.'							;Одиночные проверки на некоторые спецсимволы
		jne no_dot_pre_a
		
		push SI								;Сохраняем SI
		sub SI, 2							;SI на предыдущий символ
		lodsb								;Загружаем байт
		pop SI								;Восстанавливаем SI
		
		cmp AL, '.'							;Если точка - две точки идут подряд
		je unvalid_pass						;Емейл невалиден
		
		jmp end_pre_a
		no_dot_pre_a:
	
		cmp AL, '+'
		je end_pre_a
	
		cmp AL, '_'
		je end_pre_a
	
		cmp AL, '-'
		je end_pre_a
	
		cmp AL, 39 ;'\''
		je end_pre_a
	
		cmp AL, 48							;Отсекаем спецсимволы
		jl unvalid_pass
end_pre_a:
		cmp AL, '@'							;Пока не найдём в строке @
		jne pre_a							;Повторяем проверки в цикле
	
		jmp pass_pass						;Небольшой костыль, нужный для работы условных переходов
no_email_pass:								;Без него выдаёт ошибку relative jump out of range by ....h
		jmp no_email
unvalid_pass:
		jmp unvalid
pass_pass:

;========================================================================================================================
;											Обработка после знака @															
;========================================================================================================================

		push SI								;Сохраняем SI
		sub SI, 2							;SI на предыдущий символ
		lodsb								;Загружаем байт
		pop SI								;Восстанавливаем SI
		
		cmp AL, '.'							;Если точка - точка перед знаком @
		je unvalid_pass						;Емейл невалиден

		lodsb 								;Загружаем первый байт
		
		cmp AL, '.'							;Если точка сразу после @ - емейл не валидный
		je unvalid
		
		cmp AL, '-'							;Дефис - аналогично
		je unvalid
		
		cmp AL, '_'							;Нижнее подчёркивание - аналогично
		je unvalid
		
		mov DX, 0							;В DX будем хранить состояние проверки, зануляем его
		
		jmp start_common_post_a				;На начало обычного обработчика
		
post_a:
		lodsb								;Загружаем байт
		
		start_common_post_a:
	
		cmp AL, 122							;Отсекаем этой проверкой всю киррилицу и спецсимволы
		jg unvalid
	
		cmp AL, 96							;Эта проверка пропускает латиницу нижнего регистра
		jl no_lcase
		mov DH, 1							;Если обнаружили хотя бы одну букву, положим в DH 1
		jmp end_post_a
no_lcase:
	
		cmp AL, 90							;Отсекаем спецсимволы, расположенные между латиницей нижнего и верхнего регистра
		jg unvalid
	
		cmp AL, 65							;Эта проверка пропускает латиницу нижнего регистра
		jl no_upcase
		mov DH, 1							;Если обнаружили хотя бы одну букву, положим в DH 1
		jmp end_post_a
no_upcase:
	
		cmp AL, 57							;Отсекаем спецсимволы между цифрами и латиницей
		jg unvalid
	
		cmp AL, 47							;Пропускаем цифры
		jg end_post_a
		
		cmp AL,'.'							;Пропускаем точку
		jne no_dot
		inc DL								;Считаем количество точек в DL
		
		push SI								;Сохраняем SI
		sub SI, 2							;SI на предыдущий символ
		lodsb								;Загружаем байт
		pop SI								;Восстанавливаем SI
		
		cmp AL, '.'							;Если точка - две точки идут подряд
		je unvalid							;Емейл невалиден
		
		jmp end_post_a
no_dot:
	
		cmp AL,'-'							;Пропускаем дефис
		je end_post_a
	
		cmp AL, 48							;Отсекаем спецсимволы
		jl unvalid
end_post_a:
	
		cmp SI, DI							;Пока текущий адрес и адрес конца буфера не равны
		jne post_a							;Повторяем в цикле
		
;========================================================================================================================
;											Последние проверки на валидность														
;========================================================================================================================
	
		cmp DH, 1							;Если в DH лежит 0, то в домене только цифры, такой емейл невалиден
		jne unvalid
	
		cmp DL, 1							;Если количество точек > 1, в домене более одного поддомена, такой емейл не валиден
		jg unvalid

;========================================================================================================================
;											Запись валидного емейла в файл														
;========================================================================================================================

valid:
		pop SI								;Восстанавливаем SI
		
		mov DX, valid_count 				;Увеличиваем переменную с количеством валидных емейлом
		inc DX 
		mov valid_count, DX 
	
		mov DS:[DI],byte ptr 0Dh			;Записываем в конец буфера символы переноса строки
	
		inc DI
	
		mov DS:[DI],byte ptr 0Ah
	
		push CX								;Сохраняем CX в стек
	
		mov CX, DI							;Вычисляем длинну записываемой строки
		mov DX, offset o_buf
		sub CX, DX
	
		mov BX, handle2						;Записываем строку в выходной файл	
		mov AH, 40h
		int 21h
	
		pop CX								;Восстанавливаем CX
	
		jmp no_email						;Уходим на конец обработчика
		
;========================================================================================================================
;											Увеличение количества невалидных														
;========================================================================================================================

unvalid:
		pop SI								;Восстанавливаем SI
		
		mov DX, unvalid_count 				;Увеличиваем переменную с количеством невалидных емейлом
		inc DX 
		mov unvalid_count, DX 
		
;========================================================================================================================
;											Конец обработчика строки														
;========================================================================================================================

no_email:
	
		mov DX, 0							;Зануляем DX, так как используем его для проверки на найденную в строке @
		mov DI, offset o_buf				;В DI адрес буфера со строкой, пишем его прямо поверх стаых данных
	
		ret									;Возврат управления
line_proc endp

;========================================================================================================================
;											Процедура вывода сообщения об ошибке при открытии/создании файла														
;========================================================================================================================
	
print_error proc
	
		mov AH, 9							;Просто выводим соответствующее сообщение				
		mov DX, offset mes_i
		int 21h
	
		ret
print_error endp

;########################################################################################################################
;#											Переменные для парсера												   		#	
;########################################################################################################################
							
		handle dw 0h						;Хендл входного файла
		
		f_adr2 db 'result.txt',0			;Имя выходного файла
		handle2 dw 0h						;Хендл выходного файла
	
		valid_count DW ?					;Количество валидных
		unvalid_count DW ?					;Количество невалидных
	
		o_buf db 600 dup (?)				;Буфер для строки
	
		buf db 45000 dup (?)				;Буфер в который переписываем куски входного файла
	
		mes_i db 'ERROR','$'				;Сообщения 
	
		mes_time db 'RUNTIME(in hex):  ',0Dh,0Ah,'$'
		mes_valid db 'VALID(in hex):  ',0Dh,0Ah,'$'
		mes_unvalid db 'UNVALID(in hex):  ',0Dh,0Ah,'$'
	
		mes_eol db 0Dh,0Ah,'$'				;Перенос строки
	
code_seg ends
end start
